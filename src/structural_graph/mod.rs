//! Structural graph representation and parsing for asynchronous circuit descriptions.
//!
//! This module provides the data structures and parsing functionality for representing
//! the structural connectivity of asynchronous circuits. A structural graph represents
//! a circuit as a directed graph where:
//! - **Nodes** are circuit components (ports or registers)
//! - **Edges** are channels that connect components with timing information
//!
//! # Input Format
//!
//! The module parses a simple text-based format generated by Pulsar's `syn_rtl` tool.
//! Each line defines a circuit component:
//!
//! ```text
//! Port "input" [("output", 100)]
//! DataReg "register" [("output", 75)]
//! Port "output" []
//! ```
//!
//! The format syntax is:
//! - `<Type> <Name> [<adjacency_list>]`
//! - `<Type>`: One of `Port`, `DataReg`, `NullReg`, `ControlReg`, or `UnsafeReg`
//! - `<Name>`: A quoted string identifier
//! - `<adjacency_list>`: A comma-separated list of `("target", delay)` tuples
//!
//! # Component Types
//!
//! - **`Port`**: External interface ports (inputs/outputs), no internal structure, cost = 0
//! - **`DataReg`**: Data registers with internal structure (3 nodes: main + s0 + s1)
//! - **`NullReg`**: Null registers, simple register with cost = 10
//! - **`ControlReg`**: Control registers with higher cost = 50
//! - **`UnsafeReg`**: Unsafe registers with internal structure (2 nodes: main + s0)
//!
//! # Channel Phases
//!
//! Channels have an initial phase that determines the handshaking protocol state:
//! - **`ReqData`**: Request data phase
//! - **`ReqNull`**: Request null/spacer phase
//! - **`AckData`**: Acknowledge data phase
//! - **`AckNull`**: Acknowledge null/spacer phase
//!
//! The initial phase affects how tokens are distributed when converting to HBCN.
//!
//! # Usage
//!
//! ```
//! use hbcn::structural_graph::parse;
//!
//! let input = r#"
//!     Port "input" [("reg", 50)]
//!     DataReg "reg" [("output", 75)]
//!     Port "output" []
//! "#;
//!
//! match parse(input) {
//!     Ok(graph) => {
//!         println!("Graph has {} nodes and {} edges",
//!                  graph.node_count(), graph.edge_count());
//!     },
//!     Err(e) => eprintln!("Parse error: {}", e),
//! }
//! ```

mod ast;

// Include the generated parser with clippy warnings suppressed
#[allow(clippy::all)]
mod parser {
    #![allow(clippy::all)]
    #![allow(dead_code)]
    #![allow(unused_variables)]
    #![allow(unused_imports)]
    #![allow(non_snake_case)]
    #![allow(non_camel_case_types)]
    #![allow(non_upper_case_globals)]
    include!(concat!(env!("OUT_DIR"), "/structural_graph/parser.rs"));
}

use ast::{Entry, EntryType};
use petgraph::{graph, stable_graph::StableGraph};
use std::{collections::HashMap, error::Error, fmt};
use string_cache::DefaultAtom;

/// Type alias for symbols used throughout the structural graph.
///
/// Symbols are interned strings using `DefaultAtom` for efficient comparison and memory usage.
pub type Symbol = DefaultAtom;

// Cost constants for different register types
const REGISTER_COST: usize = 10;
const CONTROL_REG_COST: usize = 50;

/// Represents a circuit component (port or register) in the structural graph.
///
/// Circuit nodes are the vertices of the structural graph. They represent physical
/// components in the asynchronous circuit design.
///
/// # Variants
///
/// - **`Port(Symbol)`**: An external interface port (input or output). Ports have no
///   internal structure and a base cost of 0.
///
/// - **`Register { name, cost }`**: A register component with an associated cost.
///   Different register types have different costs:
///   - Regular registers: 10
///   - Control registers: 50
///
/// # Example
///
/// ```
/// use hbcn::structural_graph::{CircuitNode, Symbol};
/// use string_cache::DefaultAtom;
///
/// let port = CircuitNode::Port(DefaultAtom::from("input"));
/// let register = CircuitNode::Register {
///     name: DefaultAtom::from("reg1"),
///     cost: 10,
/// };
///
/// assert_eq!(port.base_cost(), 0);
/// assert_eq!(register.base_cost(), 10);
/// ```
#[derive(Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub enum CircuitNode {
    /// External interface port.
    Port(Symbol),
    /// Register component with name and cost.
    Register { name: Symbol, cost: usize },
}

impl CircuitNode {
    /// Returns the name of this circuit node.
    ///
    /// Both ports and registers have names, allowing them to be referenced in adjacency lists.
    pub fn name(&self) -> &Symbol {
        match self {
            CircuitNode::Port(name) => name,
            CircuitNode::Register { name, .. } => name,
        }
    }

    /// Returns the base cost of this circuit node.
    ///
    /// Ports have a cost of 0, while registers have their associated cost (10 for regular
    /// registers, 50 for control registers). This cost is used in delay calculations when
    /// converting to HBCN.
    pub fn base_cost(&self) -> usize {
        match self {
            CircuitNode::Port(_) => 0,
            CircuitNode::Register { cost, .. } => *cost,
        }
    }
}

impl fmt::Display for CircuitNode {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            CircuitNode::Port(name) => write!(f, "Port \"{}\"", name),
            CircuitNode::Register { name, cost } => {
                write!(f, "Register \"{}\" with cost {}", name, cost)
            }
        }
    }
}

/// Represents the handshaking protocol phase for a channel.
///
/// The channel phase indicates the initial state of the handshaking protocol when
/// converting from a structural graph to an HBCN. This determines which places in the
/// HBCN will initially contain tokens.
///
/// The phases follow the 4-phase handshaking protocol used in asynchronous circuits:
/// 1. Request data (`ReqData`)
/// 2. Acknowledge data (`AckData`)
/// 3. Request null/spacer (`ReqNull`)
/// 4. Acknowledge null (`AckNull`)
///
/// # Example
///
/// ```
/// use hbcn::structural_graph::ChannelPhase;
///
/// // A channel starting in request data phase
/// let phase = ChannelPhase::ReqData;
/// ```
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]
pub enum ChannelPhase {
    /// Acknowledge null phase - acknowledgment of spacer/null propagation.
    AckNull,
    /// Request data phase - request for data propagation.
    ReqData,
    /// Acknowledge data phase - acknowledgment of data propagation.
    AckData,
    /// Request null phase - request for spacer/null propagation.
    ReqNull,
}

/// Represents a channel connecting two circuit nodes.
///
/// A channel is an edge in the structural graph that carries timing and protocol
/// information. Channels define the connections between circuit components and specify:
///
/// - The initial handshaking protocol phase
/// - Whether the channel is internal (between internal components) or external
/// - The virtual delay associated with traversing this channel
///
/// # Fields
///
/// - **`initial_phase`**: The initial phase of the handshaking protocol. This determines
///   which places in the HBCN will be initially marked with tokens.
///
/// - **`is_internal`**: Whether this channel is internal (connects internal register stages)
///   or external (connects ports or external interfaces).
///
/// - **`virtual_delay`**: The delay (in time units) associated with traversing this channel.
///   This is used as the base weight for forward places in the HBCN conversion.
///
/// # Example
///
/// ```
/// use hbcn::structural_graph::{Channel, ChannelPhase};
///
/// let external_channel = Channel {
///     initial_phase: ChannelPhase::AckNull,
///     is_internal: false,
///     virtual_delay: 100.0,
/// };
///
/// let internal_channel = Channel {
///     initial_phase: ChannelPhase::ReqData,
///     is_internal: true,
///     virtual_delay: 10.0,
/// };
/// ```
#[derive(Debug, Clone, Copy, PartialEq)]
pub struct Channel {
    /// Initial handshaking protocol phase for this channel.
    pub initial_phase: ChannelPhase,
    /// Whether this channel is internal (between register stages).
    pub is_internal: bool,
    /// Virtual delay for traversing this channel.
    pub virtual_delay: f64,
}

/// Type alias for the structural graph representation.
///
/// A `StructuralGraph` is a directed graph where:
/// - **Nodes** are [`CircuitNode`]s (ports or registers)
/// - **Edges** are [`Channel`]s with timing and protocol information
///
/// This graph represents the structural connectivity of an asynchronous circuit before
/// conversion to an HBCN. It can be parsed from a text description using [`parse`].
pub type StructuralGraph = StableGraph<CircuitNode, Channel>;

type LarlPopError<'a> = lalrpop_util::ParseError<usize, parser::Token<'a>, &'static str>;

/// Errors that can occur when parsing a structural graph.
///
/// Parsing errors occur when:
/// - The input syntax is invalid
/// - A circuit component is defined multiple times
/// - A referenced component in an adjacency list doesn't exist
///
/// # Example
///
/// ```
/// use hbcn::structural_graph::{parse, ParseError};
///
/// let input = r#"
///     Port "a" [("undefined", 10)]
/// "#;
///
/// match parse(input) {
///     Err(ParseError::UndefinedElement(name)) => {
///         assert_eq!(name.as_ref(), "undefined");
///     },
///     _ => panic!("Expected undefined element error"),
/// }
/// ```
#[derive(Debug, PartialEq, Eq)]
pub enum ParseError {
    /// Syntax error in the input text (malformed input format).
    SyntaxError(String),
    /// A circuit component was defined multiple times.
    MultipleDefinitions(CircuitNode),
    /// A component referenced in an adjacency list was never defined.
    UndefinedElement(Symbol),
}

impl fmt::Display for ParseError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            ParseError::SyntaxError(err) => write!(f, "{}", err),
            ParseError::MultipleDefinitions(node) => {
                write!(f, "Multiple Definitions of {}", node.name())
            }
            ParseError::UndefinedElement(name) => write!(f, "Undefined Element: {}", name),
        }
    }
}

impl Error for ParseError {}

impl From<LarlPopError<'_>> for ParseError {
    fn from(err: LarlPopError) -> Self {
        ParseError::SyntaxError(format!("{}", err))
    }
}

/// Parses a structural graph description into a [`StructuralGraph`].
///
/// This function parses the text format generated by Pulsar's `syn_rtl` tool and converts
/// it into a graph representation suitable for timing analysis and HBCN conversion.
///
/// # Input Format
///
/// Each line defines a circuit component:
/// ```text
/// <Type> <Name> [<adjacency_list>]
/// ```
///
/// Where:
/// - `<Type>` is one of: `Port`, `DataReg`, `NullReg`, `ControlReg`, `UnsafeReg`
/// - `<Name>` is a quoted string identifier
/// - `<adjacency_list>` is a comma-separated list of `("target", delay)` tuples
///
/// # Component Type Handling
///
/// Different component types are handled specially:
///
/// - **Port**: Simple node with no internal structure
/// - **DataReg**: Expanded into 3 nodes (main + s0 + s1) with internal channels
/// - **NullReg**: Simple register node with cost 10
/// - **ControlReg**: Register node with cost 50
/// - **UnsafeReg**: Expanded into 2 nodes (main + s0) with internal channels
///
/// # Channel Initialization
///
/// Channels are initialized with phases based on their type:
/// - **External channels** (non-UnsafeReg): `AckNull` phase
/// - **Internal channels** (UnsafeReg or DataReg internal): `ReqData` or `ReqNull` phase
///
/// # Errors
///
/// Returns an error if:
/// - The input syntax is malformed (`SyntaxError`)
/// - A component is defined multiple times (`MultipleDefinitions`)
/// - An adjacency list references an undefined component (`UndefinedElement`)
///
/// # Example
///
/// ```
/// use hbcn::structural_graph::parse;
///
/// let input = r#"
///     Port "input" [("reg", 50)]
///     DataReg "reg" [("output", 75)]
///     Port "output" []
/// "#;
///
/// match parse(input) {
///     Ok(graph) => {
///         // Graph can now be used for analysis or HBCN conversion
///         println!("Parsed graph with {} nodes", graph.node_count());
///     },
///     Err(e) => eprintln!("Parse error: {}", e),
/// }
/// ```
pub fn parse(input: &str) -> Result<StructuralGraph, ParseError> {
    let nodes = parser::GraphParser::new().parse(input)?;

    let mut ret = StructuralGraph::new();
    let mut lut = HashMap::new();

    let mut adjacency: Vec<(graph::NodeIndex, Vec<(Symbol, Channel)>)> = Vec::new();

    for Entry {
        entry_type,
        name,
        adjacency_list,
    } in nodes.into_iter()
    {
        let c = match entry_type {
            EntryType::DataReg => {
                let s0: Symbol = format!("{}/s0", name.as_ref()).into();
                let s1: Symbol = format!("{}/s1", name.as_ref()).into();

                let cn = CircuitNode::Register {
                    name: name.clone(),
                    cost: REGISTER_COST,
                };
                let cni = ret.add_node(cn);
                lut.insert(name, cni);

                let s0n = CircuitNode::Register {
                    name: s0.clone(),
                    cost: REGISTER_COST,
                };
                let s0i = ret.add_node(s0n);
                lut.insert(s0.clone(), s0i);
                adjacency.push((
                    cni,
                    vec![(
                        s0,
                        Channel {
                            initial_phase: ChannelPhase::ReqNull,
                            is_internal: true,
                            virtual_delay: 10.0,
                        },
                    )],
                ));
                adjacency.push((
                    s0i,
                    vec![(
                        s1.clone(),
                        Channel {
                            initial_phase: ChannelPhase::ReqData,
                            is_internal: true,
                            virtual_delay: 10.0,
                        },
                    )],
                ));

                CircuitNode::Register {
                    name: s1,
                    cost: REGISTER_COST,
                }
            }
            EntryType::UnsafeReg => {
                let s0: Symbol = format!("{}/s0", name.as_ref()).into();

                let cn = CircuitNode::Register {
                    name: name.clone(),
                    cost: REGISTER_COST,
                };
                let cni = ret.add_node(cn);
                lut.insert(name, cni);

                adjacency.push((
                    cni,
                    vec![(
                        s0.clone(),
                        Channel {
                            initial_phase: ChannelPhase::ReqNull,
                            is_internal: true,
                            virtual_delay: 10.0,
                        },
                    )],
                ));

                CircuitNode::Register {
                    name: s0,
                    cost: REGISTER_COST,
                }
            }
            EntryType::Port => CircuitNode::Port(name),
            EntryType::NullReg => CircuitNode::Register {
                name,
                cost: REGISTER_COST,
            },
            EntryType::ControlReg => CircuitNode::Register {
                name,
                cost: CONTROL_REG_COST,
            },
        };
        let ni = ret.add_node(c.clone());
        if lut.insert(c.name().clone(), ni).is_some() {
            return Err(ParseError::MultipleDefinitions(c));
        }
        adjacency.push((
            ni,
            adjacency_list
                .into_iter()
                .map(|(s, n)| {
                    (
                        s,
                        if entry_type == EntryType::UnsafeReg {
                            Channel {
                                initial_phase: ChannelPhase::ReqData,
                                is_internal: true,
                                virtual_delay: n,
                            }
                        } else {
                            Channel {
                                initial_phase: ChannelPhase::AckNull,
                                is_internal: false,
                                virtual_delay: n,
                            }
                        },
                    )
                })
                .collect(),
        ));
    }

    for (ni, adjacency_list) in adjacency.into_iter() {
        for (x, channel) in adjacency_list.into_iter() {
            if let Some(xi) = lut.get(&x) {
                ret.add_edge(ni, *xi, channel);
            } else {
                return Err(ParseError::UndefinedElement(x.clone()));
            }
        }
    }

    Ok(ret)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn parse_valid() {
        let input = r#"
            Port "a" [("result", 10)]
            Port "b" [("result", 20)]
            NullReg "result" [("acc", 30), ("output", 40)]
            DataReg "acc" [("result", 50)]
            Port "output" []
            "#;
        let result = parse(input);
        assert!(result.is_ok());

        let g = result.unwrap();
        assert_eq!(g.edge_count(), 7);
        assert_eq!(g.node_count(), 7);
    }

    #[test]
    fn parse_err_undefined() {
        let input = r#"
            Port "a" [("result", 10)]
            Port "b" [("result", 20)]
            NullReg "result" [("acc", 30), ("output", 40)]
            DataReg "acc" [("result", 50)]
            "#;
        let result = parse(input);
        assert!(matches!(result, Err(ParseError::UndefinedElement(_))));
        if let Err(ParseError::UndefinedElement(node)) = result {
            assert_eq!(node.as_ref(), "output");
        }
    }

    #[test]
    fn parse_err_syntax() {
        let input = r#"
            Port "a" [("result", 10)]
            Port "b" [("result", 20)]
            NullReg "result" [("acc", 30) ("output", 40)]
            DataReg "acc" [("result", 50)]
            Port "output" []
            "#;
        let result = parse(input);
        assert!(matches!(result, Err(ParseError::SyntaxError(_))));
    }

    #[test]
    fn parse_realistic_port_names() {
        let input = r#"
            Port "port:ARV/instruction[31]" [("inst:ARV/decode_retime_s1_94_reg", 130), ("inst:ARV/decode_retime_s1_137_reg", 100)]
            Port "port:ARV/mem_data_in[0]" []
            DataReg "inst:ARV/decode_retime_s1_94_reg" [("inst:ARV/some_output_reg", 75)]
            DataReg "inst:ARV/decode_retime_s1_137_reg" [("inst:ARV/some_output_reg", 85)]
            DataReg "inst:ARV/some_output_reg" []
            "#;
        let result = parse(input);
        assert!(result.is_ok());

        let g = result.unwrap();
        // 2 Ports (2 nodes) + 3 DataRegs (9 nodes, 3 each) = 11 nodes total
        assert_eq!(g.node_count(), 11);
        // Two ports connecting to two DataRegs, which both connect to one output DataReg
        // Plus internal connections for DataRegs: 2 + 2 + 2 + 2 + 2 = 10 edges
        assert_eq!(g.edge_count(), 10);
    }

    #[test]
    fn parse_complex_adjacency_list() {
        let input = r#"
            Port "input" [("reg1", 10), ("reg2", 20), ("reg3", 30), ("reg4", 40)]
            DataReg "reg1" [("output", 50)]
            DataReg "reg2" [("output", 60)]
            DataReg "reg3" [("output", 70)]
            DataReg "reg4" [("output", 80)]
            Port "output" []
            "#;
        let result = parse(input);
        assert!(result.is_ok());

        let g = result.unwrap();
        // 2 Ports (2 nodes) + 4 DataRegs (12 nodes, 3 each) = 14 nodes total
        assert_eq!(g.node_count(), 14);
        // 4 connections from input to DataRegs + 4 connections from DataRegs to output + 8 internal DataReg connections (2 each) = 16 edges
        assert_eq!(g.edge_count(), 16);
    }

    #[test]
    fn parse_all_register_types() {
        let input = r#"
            Port "input" [("data_reg", 100)]
            DataReg "data_reg" [("null_reg", 200)]
            NullReg "null_reg" [("control_reg", 300)]
            ControlReg "control_reg" [("unsafe_reg", 400)]
            UnsafeReg "unsafe_reg" [("output", 500)]
            Port "output" []
            "#;
        let result = parse(input);
        assert!(result.is_ok());

        let g = result.unwrap();
        // 2 Ports + 1 DataReg (3 nodes) + 1 NullReg + 1 ControlReg + 1 UnsafeReg (2 nodes) = 9 nodes total
        assert_eq!(g.node_count(), 9);
        // 5 explicit connections + 2 internal DataReg connections + 1 internal UnsafeReg connection = 8 edges
        assert_eq!(g.edge_count(), 8);
    }

    #[test]
    fn parse_floating_point_weights() {
        let input = r#"
            Port "input" [("reg1", 10.5), ("reg2", 20.75)]
            DataReg "reg1" [("output", 100.0)]
            DataReg "reg2" [("output", 150.25)]
            Port "output" []
            "#;
        let result = parse(input);
        assert!(result.is_ok());

        let g = result.unwrap();
        // 2 Ports + 2 DataRegs (6 nodes, 3 each) = 8 nodes total
        assert_eq!(g.node_count(), 8);
        // 2 connections from input to DataRegs + 2 connections from DataRegs to output + 4 internal DataReg connections = 8 edges
        assert_eq!(g.edge_count(), 8);
    }

    #[test]
    fn parse_test_graph_format() {
        // Test the exact format from test.graph file
        let input = r#"Port "a" [("b", 20)]
Port "b" []"#;
        let result = parse(input);
        assert!(result.is_ok());

        let g = result.unwrap();
        assert_eq!(g.node_count(), 2); // Two ports
        assert_eq!(g.edge_count(), 1); // One connection from a to b
    }
}
